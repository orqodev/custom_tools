import hou
from husd import assetutils
from pxr import Usd, Gf, UsdGeom

def create_lookdev_camera(asset_name):
    '''
    Creates a lookdev Camera based on a bbox for the asset
    and allows you to load your own camera
    '''

    # Use the drop down menu to select example code snippets.
    node = hou.pwd()

    # Add code to fetch node parameters and evaluate primitive patterns.
    # This should be done before calling editableStage or editableLayer.
    # paths = hou.LopSelectionRule("/*").expandedPaths(node.input(0))

    # Add code to modify the stage.
    stage = node.editableStage()

    _create_parameters(node,asset_name)

    # Get parameters values
    target_path = node.evalParm("target")
    camera_path = node.evalParm("camera_path")
    spin = node.evalParm("spin")
    pitch = node.evalParm("pitch")
    distance = node.evalParm("distance")
    animate = node.evalParm("animate")
    frames = node.evalParm("frames")
    start_frame = node.evalParm("start_frame")
    use_existing_camera = node.evalParm("use_existing_camera")
    existing_camera_path = node.evalParm("existing_camera_path")

    # Ensure that the target path is valid
    if not target_path.startswith('/'):
        target_path = '/' + target_path

    # Get the target prim
    target_prim = stage.GetPrimAtPath(target_path)


    # Validate that the target prim exists and is valid
    if not target_prim or not target_prim.IsValid():
        raise hou.NodeError(f"Target prim not found or invalid at path: {target_path}")

    # Compute world-space bounds for framing (purposes: default, render)
    try:
        bounds = _compute_world_bounds(target_prim)
    except Exception as e:
        raise hou.NodeError(f"Failed to compute bounding box for prim at {target_path}: {str(e)}")
    # Derive center and diagonal for lookdev rig
    bmin = bounds.GetMin()
    bmax = bounds.GetMax()
    center = (bmin + bmax) * 0.5
    diag = (bmax - bmin).GetLength()
    # Check which camera to use
    camera_to_use = existing_camera_path if use_existing_camera else camera_path

    # Check if the camera exists
    existing_camera = None
    if use_existing_camera:
        existing_prim = stage.GetPrimAtPath(existing_camera_path)
        if existing_prim and existing_prim.IsA(UsdGeom.Camera):
            existing_camera = UsdGeom.Camera(existing_prim)
        else:
            raise hou.NodeError(f"Existing camera not found at {existing_camera_path}")


    # Create or use the camera
    if existing_camera:
        camera = existing_camera
    else:
        camera = UsdGeom.Camera.Define(stage, camera_path)
        # Asset settings to the new camera
        camera.GetHorizontalApertureAttr().Set(10.0)
        camera.GetVerticalApertureAttr().Set(10.0)
        camera.GetFocalLengthAttr().Set(35.0)
        camera.GetClippingRangeAttr().Set(Gf.Vec2f(0.01,100000.0))

    if animate:
        for frame in range(frames):
            current_frame = start_frame + frame
            time_code = Usd.TimeCode(current_frame)
            # Calculate the spin angle based on the frame
            current_spin = spin + (frame/frames * 360)
            matrix = _make_orbit_matrix_via_assetutils(bounds, pitch, current_spin, distance)
            _author_single_matrix_xform(camera.GetPrim(), matrix, time_code)



    else:
        # Static Camera
        matrix = _make_orbit_matrix_via_assetutils(bounds, pitch, spin, distance)
        _author_single_matrix_xform(camera.GetPrim(), matrix)

def _create_framed_camera(stage, bounds, pitch, spin, distance):
    '''
    Create a thumbnail camera using the assetutils createFramedCameraToBounds method
    Args:
        bounds:
        cameraprimpath:
        pitch:
        spin:
        distance:

    Returns:
        temp_camera = The camera generated by the createFramedCameraToBounds method

    '''

    temp_stage = Usd.Stage.CreateInMemory()
    temp_camera = assetutils.createFramedCameraToBounds(
        stage,
        bounds,
        cameraprimpath = "/TempCamera",
        rotatex=25+pitch,
        rotatey=35+spin,
        offsetdistance=distance)

    return temp_camera


def _compute_world_bounds(prim):
    """Compute world bounds (default + render purposes) and return the Gf.Range3d box."""
    bbox_cache = UsdGeom.BBoxCache(Usd.TimeCode.Default(), ["default", "render"])
    # ComputeWorldBound returns Gf.BBox3d; GetBox() is Gf.Range3d
    return bbox_cache.ComputeWorldBound(prim).GetBox()


def _make_orbit_matrix_via_assetutils(bounds, pitch, spin, distance):
    """Generate a single framing matrix using assetutils.createFramedCameraToBounds."""
    temp_stage = Usd.Stage.CreateInMemory()
    temp_cam = assetutils.createFramedCameraToBounds(
        temp_stage,
        bounds,
        cameraprimpath="/TempCamera",
        rotatex=25 + pitch,
        rotatey=35 + spin,
        offsetdistance=distance,
    )
    # Extract the transform authored by assetutils that frames to bounds
    temp_xf = UsdGeom.Xformable(temp_cam)
    for xform_op in temp_xf.GetOrderedXformOps():
        # be permissive in matching; SideFX typically uses suffix 'frameToBounds'
        if xform_op.GetOpName().endswith("frameToBounds") or xform_op.GetOpType() == UsdGeom.XformOp.TypeTransform:
            return xform_op.Get()
    # Fallback to identity if nothing found
    return Gf.Matrix4d(1)


def _author_single_matrix_xform(camera_prim, matrix, timecode=None):
    """Author exactly one TransformOp named orbitTransform; add time samples if provided.
    camera_prim can be a Usd.Prim or schema with GetPrim().
    """
    prim = camera_prim if isinstance(camera_prim, Usd.Prim) else camera_prim.GetPrim()
    xform = UsdGeom.Xformable(prim)
    # Find existing orbitTransform op if present
    existing = None
    for op in xform.GetOrderedXformOps():
        if op.GetOpName().endswith("orbitTransform"):
            existing = op
            break
    if existing is None:
        # Clear any previous stack and author a single transform op
        xform.ClearXformOpOrder()
        existing = xform.AddTransformOp(opSuffix="orbitTransform")
    # Author value (time sampled if timecode provided)
    if timecode is None:
        existing.Set(matrix)
    else:
        existing.Set(matrix, timecode)



def _create_parameters(node,asset_name):
    ''' Function to create parameters needed for the LookDev Camera '''
    ptg = node.parmTemplateGroup()
    find_parm = ptg.find('target')

    if not find_parm:
        new_folder = hou.FolderParmTemplate(
            name="camera_folder",
            label="LookDev Camera Settings",
            folder_type=hou.folderType.Simple
        )

        target_string = hou.StringParmTemplate(
            name="target",
            label="Target Prim",
            default_value=(f"/{asset_name}",),
            num_components=1
        )

        camera_string = hou.StringParmTemplate(
            name="camera_path",
            label="Camera Path",
            num_components=1,
            default_value=("/ThumbnailCamera",)
        )

        pitch_float = hou.FloatParmTemplate(
            name="pitch",
            label="Pitch Camera",
            num_components=1,
            default_value=(0.0,),
            min=-90.0,
            max=90.0,
        )

        spin_float = hou.FloatParmTemplate(
            name="spin",
            label="Spin Camera",
            num_components=1,
            default_value=(0.0,),
            min=-180.0,
            max=180.0,
        )

        distance_float = hou.FloatParmTemplate(
            name="distance",
            label="Distance",
            num_components=1,
            default_value=(0.0,),
            min=-50.0,
            max=50.0,
        )

        animated_cam_folder = hou.FolderParmTemplate(
            name="animated_cam_folder",
            label="LookDev Animated Camera Settings",
        )

        animate_toggle = hou.ToggleParmTemplate(
            name="animate",
            label="Animate",
        )

        use_camera = hou.ToggleParmTemplate(
            name="use_existing_camera",
            label="Use Existing Camera",
        )

        camera_path_string = hou.StringParmTemplate(
            name="existing_camera_path",
            label="Existing Camera Path",
            num_components=1,
            default_value=("/cameras/camera_render",),
            disable_when="{use_existing_camera == 0}"
        )

        num_frames = hou.IntParmTemplate(
            name="frames",
            label="Frames",
            num_components=1,
            default_value=(60,),
            min=30,
            disable_when="{animate == 0}"
        )

        star_frame_string = hou.IntParmTemplate(
            name="start_frame",
            label="Start Frame",
            num_components=1,
            default_value=(0,),
            disable_when="{animate == 0}"
        )

        new_folder.addParmTemplate(target_string)
        new_folder.addParmTemplate(camera_string)
        new_folder.addParmTemplate(use_camera)
        new_folder.addParmTemplate(camera_path_string)
        new_folder.addParmTemplate(spin_float)
        new_folder.addParmTemplate(pitch_float)
        new_folder.addParmTemplate(distance_float)
        animated_cam_folder.addParmTemplate(animate_toggle)
        animated_cam_folder.addParmTemplate(num_frames)
        animated_cam_folder.addParmTemplate(star_frame_string)
        new_folder.addParmTemplate(animated_cam_folder)
        ptg.append(new_folder)

        node.setParmTemplateGroup(ptg)
